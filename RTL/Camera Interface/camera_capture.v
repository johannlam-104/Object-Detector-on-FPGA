// capture.v
//
// This module captures incoming pixel data and is synchronous to the
// 24 MHz clock generated by the XCLK pin of the OV7670 camera.
//
// The OV7670 outputs 30FPS in VGA.
//
module capture 
    (
    input  wire        i_pclk,     // 24 MHz; sourced from OV7670 camera
    input  wire        i_rstn,     // synchronous active low reset
    input  wire        i_cfg_done, // cam config done flag
    output wire        o_status,   // asserted when capturing

    // OV7670 camera interface
    input  wire        i_vsync,    // active-high, indicates start of frame
    input  wire        i_href,     // active-high, indicates row data transmission
    input  wire [7:0]  i_data,     // pixel data from camera
    
    // FIFO write interface   
    output reg         o_wr,       // fifo write enable
    output reg  [15:0] o_wdata,    // fifo write data; {red[4:0], green[5:0], blue[4:0]}

    output wire        o_sof       // start of frame flag
    );

    reg        nxt_wr;
    reg [15:0] nxt_wdata;
    reg [7:0]  byte1_data, nxt_byte1_data;
    
    reg [4:0] r5;
    reg [5:0] g6;
    reg [4:0] b5;

    reg        pixel_half, nxt_pixel_half;

    reg [1:0]  STATE, NEXT_STATE;
    localparam STATE_IDLE    = 0,
               STATE_ACTIVE  = 1,
               STATE_INITIAL = 2;

    initial begin
        o_wr  = 0;
        STATE = STATE_INITIAL;
    end
    assign o_status = (STATE == STATE_ACTIVE);

    reg vsync1, vsync2;
    wire vsync_posedge;

// **** vsync negedge detector ****
//
    always@(posedge i_pclk) begin
        if(!i_rstn) begin
            {vsync1, vsync2} <= 2'b0;
        end
        else begin
            vsync1 <= i_vsync;
            vsync2 <= vsync1;
        end
    end
    assign o_sof         = ((vsync1 == 0) && (vsync2 == 1)); // vsync negedge
    assign vsync_posedge = ((vsync1 == 1) && (vsync2 == 0));

// **** Next State Logic ****
//
    always@* begin
        nxt_wr           = 0;
        nxt_wdata        = o_wdata;
        nxt_byte1_data   = byte1_data;
        nxt_pixel_half   = pixel_half;
        NEXT_STATE       = STATE;

        case(STATE)

            STATE_INITIAL: begin
                NEXT_STATE = (i_cfg_done && o_sof) ? STATE_IDLE : STATE_INITIAL;
                nxt_pixel_half = 1'b0;
            end

            // camera not outputting 
            STATE_IDLE: begin
                nxt_wr         = 0;
                nxt_pixel_half = 1'b0;
                NEXT_STATE = (o_sof) ? STATE_ACTIVE : STATE_IDLE;
            end

            // camera outputting display data
            STATE_ACTIVE: begin
                // Reset half toggle when HREF drops (between lines/blanking)
                if (!i_href) begin
                    nxt_wr         = 0;
                    nxt_pixel_half = 1'b0;
                end 
                else begin
                    // While HREF=1, consume bytes
                    if (!pixel_half) begin
                        // First byte of RGB565
                        nxt_byte1_data = i_data;
                        nxt_wr         = 0;
                        nxt_pixel_half = 1'b1;
                    end 
                    else begin
                        // Second byte: repack to 16-bit RGB565 and write
                        // Extract fields
                        //   R[4:0] = byte1[7:3]
                        //   G[5:0] = {byte1[2:0], byte2[7:5]}
                        //   B[4:0] = byte2[4:0]
                        r5 = byte1_data[7:3];
                        g6 = {byte1_data[2:0], i_data[7:5]};
                        b5 = i_data[4:0];

                        nxt_wdata      = {r5, g6, b5};
                        nxt_wr         = 1'b1;          // write one 16b pixel
                        nxt_pixel_half = 1'b0;          // next will be first byte
                    end
                end
                NEXT_STATE = (vsync_posedge) ? STATE_IDLE : STATE_ACTIVE;
            end

        endcase
    end

    always@(posedge i_pclk) begin
        if(!i_rstn) begin
            o_wr         <= 0;
            o_wdata      <= 0;
            byte1_data   <= 0;
            pixel_half   <= 0;
            STATE        <= STATE_INITIAL;
        end
        else begin
            o_wr         <= nxt_wr;
            o_wdata      <= nxt_wdata;
            byte1_data   <= nxt_byte1_data;
            pixel_half   <= nxt_pixel_half;
            STATE        <= NEXT_STATE;
        end
    end

endmodule
